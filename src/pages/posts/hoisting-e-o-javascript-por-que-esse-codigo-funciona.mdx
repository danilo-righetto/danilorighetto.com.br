import { Video, Link, ArticleLayout } from '@src/components/content'

export const meta = {
  author: 'Mario Souto',
  date: '2023-05-04',
  title: '#drops Hoisting no JavaScript e como ele funciona com fun√ß√µes e vari√°veis',
  description: 'Voc√™ sabe o que √© hoisting no JavaScript? Sabe como ele funciona? Neste post eu vou te explicar como ele funciona e como voc√™ pode deixar seus c√≥digos mais bonitos tirando vantagem dele.',
  source: 'devsoutinho',
  category: 'post',
  tags: ['threads', 'javascript', 'programa√ß√£o'],
  comments: true,
}

export default (props) => <ArticleLayout meta={meta} {...props} />

Voc√™ sabe me explicar por que no c√≥digo abaixo eu consigo chamar as fun√ß√µes antes de declar√°-las?

```js
export function Card({ title }) {
  return (
    <div>
      <CardHeader title={title} />
      <CardBody />
    </div>
  );
}

function CardBody({ children }) {
  return (
    <div>
      {children}
    </div>
  )
}

const CardTitle = ({ children }) => <h1>{children}</h1>;

function CardHeader({ title, children }) {
  return (
    <div>
      <CardTitle>
        {title}
      </CardTitle>
      {children}
    </div>
  )
}
```

Ontem eu falei sobre uma das [principais diferen√ßas de usar arrow function vs function](https://mariosouto.com/posts/quem-tem-medo-do-this-function-vs-arrow-function/)
e hoje eu vou falar sobre outra diferen√ßa entre elas, o hoisting.

1. Quando eu declarei o component Card, eu chamo as fun√ß√µes CardHeader e CardBody antes de declar√°-las. Isso funciona porque o JavaScript i√ßa as fun√ß√µes para o topo do escopo.

2. O que quer dizer "i√ßar para o topo do escopo"? Quer dizer que o JavaScript vai mover a declara√ß√£o da fun√ß√£o para o topo do arquivo. No caso do nosso exemplo, o escopo √© o arquivo inteiro.

3. "Ahh mas isso ai √© m√° pr√°tica". Ent√£o ao inv√©s de levar programa√ß√£o como d√≥gma, eu gosto de olhar caso a caso. Em um cen√°rio de cria√ß√£o de componentes acho saud√°vel fazer dessa forma, inclusive para quem trabalha com Flutter isso acaba sendo bastante comum.

4. Outro caso legal √© ter um arquivo que tamb√©m tem um export principal e v√°rias fun√ß√µes auxiliares, assim quem abrir o arquivo j√° vai da de cara com o principal ponto trabalhado ali. E em pequenas fun√ß√µes voc√™ pode deixar o c√≥digo mais leg√≠vel.

5. Posso fazer o mesmo com vari√°veis? Com vari√°veis acontece algo diferente, usando `var` a declara√ß√£o √© i√ßada, mas a atribui√ß√£o de valor n√£o, isso pode levar nosso c√≥digo a alguns bugs, n√£o a toa no ES2015 foi adicionado let e const.

6. Let e Const tem um comportamento mais saud√°vel, chamdo de temporal deadzone, que basicamente n√£o i√ßa a declara√ß√£o e estoura um erro se voc√™ tentar usar a vari√°vel antes de declar√°-la.

<iframe
  height="300"
  width="100%"
  scrolling="no"
  title="Exemplo de c√≥digo"
  src="https://codepen.io/omariosouto/embed/wvYPjoY?default-tab=js%2Cresult&editable=true"
  frameBorder="no"
  loading="lazy"
  allowtransparency={true.toString()}
  allowFullScreen={true}
/>

> TLDR; Toda vez que voc√™ declarar uma fun√ß√£o no JavaScript, ela vai ser i√ßada para o topo do escopo. Isso quer dizer que voc√™ pode chamar a fun√ß√£o antes de declar√°-la.

E como sempre, fica aqui as refer√™ncias para voc√™ se aprofundar no assunto:

- [Hoisting - MDN](https://developer.mozilla.org/pt-BR/docs/Glossary/Hoisting)
- [Temporal Deadzone - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#temporal_dead_zone_tdz)

Continue acompanhando o blog para mais dicas de desenvolvimento em geral! üòç

Ahh e me segue no YouTube!

https://www.youtube.com/@DevSoutinho